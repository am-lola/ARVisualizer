import os, sys, argparse, time, ntpath

# Used to colorize console output
class concolors:
    OKBLUE    = '\033[94m' # blue
    OKGREEN   = '\033[92m' # green
    WARNING   = '\033[93m' # yellow
    ERROR     = '\033[91m' # red
    ENDC      = '\033[0m'  # ends colored text; must be included to stop colored output
    BOLD      = '\033[1m'
    UNDERLINE = '\033[4m'

    def disable(self): # disables all colored output
        OKBLUE    = ''
        OKGREEN   = ''
        WARNING   = ''
        ERROR     = ''
        ENDC      = ''
        BOLD      = ''
        UNDERLINE = ''

def logError(text):
    print concolors.ERROR + text + concolors.ENDC

def logWarning(text):
    print concolors.WARNING + text + concolors.ENDC

def logInfo(text):
    print text

def logSuccess(text):
    print concolors.OKGREEN + text + concolors.ENDC

# gets a list of all non-directory objects in the given directory
def get_files_in_dir(directory):
    files = []
    for (dirpath, dirnames, filenames) in os.walk(directory):
        files.extend(filenames)
    return files

# checks the modification date on the output_file and each of the shader_files
# returns True if the output_file does not yet exist, or if any shader was
# modified more recently than output_file, otherwise returns False.
def new_shaders(shader_dir, output_file, shader_files):
    # if output_file doesn't exist, always return true
    if not os.path.isfile(output_file):
        return True

    target_mtime = os.path.getmtime(output_file)
    for shader_file in shader_files:
        if os.path.getmtime(shader_dir + shader_file) > target_mtime:
            return True
    # no shader found which was modified more recently than output_file
    return False

# generates the string used for the include guard based on the given filename
def get_include_guard(filename):
    return "_" + filename.replace('.', '_').upper() + "_"

# generates a variable declaration for the given shader filename
def get_decl(name):
    return "static constexpr auto " + "sh_" + name.replace('.', '_')

# writes out the necessary code for the include guard, class, etc
def write_header(file, filename):
    definestr = get_include_guard(filename)
    file.write("#ifndef " + definestr + "\n")
    file.write("#define " + definestr + "\n")
    file.write("\t/*********************************************\n")
    file.write("\t* This is a script-generated file.\n")
    file.write("\t* Do not edit this file directly.\n")
    file.write("\t* Do not check this file into source control.\n")
    file.write("\t*********************************************/\n\n")
    file.write("namespace ar {\n\n")
    file.write("class ShaderSources {\n")
    file.write("public:\n\n")

# closes the classes, namespaces, etc., generated by write_header
def write_footer(file, filename):
    definestr = get_include_guard(filename)
    file.write("}; // class ShaderSource\n")
    file.write("} // namespace ar\n")
    file.write("#endif // " + definestr + "\n")

# generates a C-string for the given shader and writes it to outfile
def write_shader_source(shader, outfile, shader_name):
    # write declaration
    outfile.write(get_decl(shader_name) + " =")
    # write each line of the shader as a string in the C++ source
    for line in shader:
        if len(line.strip()) < 1: # skip empty lines
            continue
        outfile.write('\n')
        outfile.write('\t' + '"' + line.replace('\n', "\\n") + '"')
    outfile.write(";\n\n")

def main(argv):
    parser = argparse.ArgumentParser(description="Generates C++ Headers for storing GLSL shaders as strings")
    parser.add_argument("source_dir",
                        help="Directory to read shaders from")
    parser.add_argument("dest_file",
                        help="Filename to write generated code to")
    args = parser.parse_args()

    if not os.path.isdir(args.source_dir):
        logError("Invalid source directory: " + args.source_dir)
        sys.exit(1)

    # Get list of shaders to process
    shader_files = get_files_in_dir(args.source_dir)

    if len(shader_files) < 1:
        logError("No files found in directory: " + args.source_dir)
        sys.exit(1)

    # if the output file exists, only do generation if one of the source files is newer
    if not new_shaders(args.source_dir, args.dest_file, shader_files):
        logInfo("No new shaders found. Exiting...")
        sys.exit(0)

    # create file to write output to
    output_dir = os.path.dirname(args.dest_file)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    with open(args.dest_file, 'w+') as outfile:
        logInfo("Generating class info")
        write_header(outfile, ntpath.basename(args.dest_file))
        for shader_file in shader_files:
            logInfo("Processing file: " + shader_file)
            with open(args.source_dir + shader_file, 'r') as infile:
                write_shader_source(infile, outfile, shader_file)

        write_footer(outfile, ntpath.basename(args.dest_file))

    logSuccess("Code Generation Complete! Output written to: " + args.dest_file)

if __name__ == "__main__":
    main(sys.argv[1:])
